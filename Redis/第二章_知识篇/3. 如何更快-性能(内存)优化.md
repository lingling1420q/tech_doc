## 1 缩减存储长度

*降低Redis内存使用最直接的方式就是缩减键（key）和值（value）的长度。*

先说下自己遇到过的情况。曾经在业务中，以key_value的方式存储过用户的行为。key是用户信息，value是用户一系列操作。value大概就是

```
[{},{},{}....]
```
这样的结构json序列话一下存储。然后在用户高峰时期，就遇到过会卡在写某些key上。而且因为redis是单线程，如果这个实例被卡在，所有发到这个实例的请求都被卡主了。引发了线上稳定性严重的抖动。

排查原因就是，value值太大。

理论上string的最大存储容量是512M。但是如果照着这个大小去用redis。就是作的节奏。

redis底层实现是SDS结构，容量是动态控制的。

扩容
> 当给sds的值追加一个字符串，而当前的剩余空间不够时，就会触发sds的扩容机制。扩容采用了空间预分配的优化策略，即分配空间的时候：如果sds 值大小< 1M ,则增加一倍； 反之如果>1M , 则当前空间加1M作为新的空间。

缩容
> 当sds的字符窜缩短了，sds的buf内会多出来一些空间，这个空间并不会马上被回收，而是暂时留着以防再用的时候进行多余的内存分配。这个是惰性空间释放的策略

所以巨大的字符串是非常消耗性能的。

### 优化方式 key
完整描述业务情况下，键值越短越好

### 优化方式 value
1. 去掉无效字段
	redis其实作为短时缓存，不是需要长期持久化的内容。所以不需要太过度设计，去超前存入一些未来可能能会用到的信息。

2. 选择比较好的序列话工具
	这个其实就是时间和空间的权衡了，比较省空间（内存）的算法会比较花时间（cpu）。
	因为需要存入需要序列话，取出也需要序列话。这个中间按需取舍。

## 2 map结构使用hash存储

避免redis被当成Memcached，大量使用get/set这样的API。

举例：
```
{
    "uid": "8768",
    "name": "abc",
    "pid": "6494271"
}
```
### 不合适一
平常可能会比较简单的使用json序列话后，存入key_value。
例如: 
key: id, value: json
缺点: 
1. value 比较大
2. 需要序列化和反序列化
3. 当只需要其中一个字段时，其实取了全部值

### 不合适二
或者组合下，拆分key
例如：
key: id_uid,  value: 8768
key: id_name, value: abc
缺点:
1. 过多的key也占大量内存
2. 需要去多个字段时，需要多次查询

### 合适
这里可以优化成hash结构存储。读取都是按需指定字段的(hmget,hmset)，也节省了程序对string的序列话。
缺点:
1. 就是需要业务端改代码

