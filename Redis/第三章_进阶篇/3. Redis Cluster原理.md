## 架构图

![](./media//202007/2020-07-09_172139.png)

Redis Cluster全局架构如上图。

蓝色单元就是一个redis节点，这个节点后面一般会有一个或多个从节点。

每个节点之间会互相通信，一个p2p网络。每个节点都会和其他节点通信，知道其他节点的信息。

Redis Cluster 的每个节点都需要维护两个TCP端口，用于为Redis提供服务的普通端口，例如6370，加上通过向数据端口添加10000获得的端口，如16379。

第二个端口是用于集群总线（集群总线端口大小为客户端服务端口+10000，这个10000是固定值），使用二进制节点到节点的通信通道(gossip 协议)。节点使用的集群总线主要用来进行故障检测、数据更新、故障转移授权等 。

### 分布式架构
RedisCluster 是去中心化。

客户端可以连接集群中的任意一个节点，集群中的任意一个节点都可对外提供服务。节点之间可共享集群配置（如槽的分配）。

我们可以理解为，集群中的任意一个节点都是中心节点。

假设有两个节点 A 和 B，客户端连接了 A 节点，并发起了一次请求 a，A 节点计算请求 a 的 key 得知该请求应该打到 B 节点上，然后 A 节点对请求 a 返回一个 MOVED B，通知客户端重定向到 B 节点。

> 客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可

### 为什么是16384个槽
分布式一个特点就是节点间有需要互相通信。
通信的时候需要不断的发送消息 ping/pong 来告知自己的节点信息，和知道其他节点的信息。

我们需要关注三个通信的内容：
1. 交换什么数据信息
2. 数据信息究竟多大
3. 定期的频率什么样

#### 交换什么数据信息
消息头里面有个myslots的char数组，长度为16383/8，这其实是一个bitmap,每一个位代表一个槽，如果该位为1，表示这个槽是属于这个节点的。

#### 数据信息究竟多大
最占空间的是myslots[CLUSTER_SLOTS/8]。
这块的大小是:
16384÷8÷1024=2kb

节点数量越多，消息体内容越大。
消息体大小是10个节点的状态信息约1kb。

#### 频率是什么样的？
redis集群内节点，每秒都在发ping消息。规律如下
(1)每秒会随机选取5个节点，找出最久没有通信的节点发送ping消息
(2)每100毫秒(1秒10次)都会扫描本地节点列表，如果发现节点最近一次接受pong消息的时间大于cluster-node-timeout/2 则立刻发送ping消息

#### 结论
(1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。
如上所述，在消息头中，最占空间的是myslots[CLUSTER_SLOTS/8]。
当槽位为65536时，这块的大小是:
65536÷8÷1024=8kb
因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。

(2)redis的集群主节点数量基本不可能超过1000个。
如上所述，集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者，不建议redis cluster节点数量超过1000个。
那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。

(3)槽位越小，节点少的情况下，压缩比高
Redis主节点的配置信息中，它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中，会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。
如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。

综上所述，作者决定取16384个槽，不多不少，刚刚好！

## 其他集群方案
Codis和Twemproxy
这个是有在分布式集群上，加了一层代理，基于zookeeper。
有兴趣可以了解下。