## 1 数据缓存
mysql这种数据库，单实例查询请求达到1000qps，就逐渐遇到性能瓶颈了。在高并发场景下，就适合加一层缓存存储热点数据，

加上redis后，qps能轻松上万。

## 2 会话缓存（Session Cache）
分布式服务的特点就是，服务是无状态的。

例如用户的第一个操作（加入购物车）的请求打给A实例，第二个请求（下单）就可能打给B实例（A和B实例可能不在一个服务器主机上），用户的信息就不可能存在内存中。

我们如何去共享用户的会话缓存（Session Cache）呢，redis就是非常适合做这件事的。

## 3 队列
list结构，能让redis能实现一个轻量级消息队列使用。

### RPUSH  生产数据

### LPOP  消费数据
当无数据时，返回空。这个需要配合sleep，如果为空进行轮询操作。


### BLPOP 消费数据（阻塞）
它是LPOP命令的阻塞版本，当给定列表内没有任何元素可供弹出的时候，连接将被BLPOP命令阻塞，直到等待超时或发现可弹出元素为止。

当给定多个key参数时，按参数key的先后顺序依次检查各个列表，弹出第一个非空列表的头元素。

上面的方式可以实现一个简单的队列，但是队列是不安全的。消费放如果拿到数据后异常了没有处理成功，这个数据就丢掉了。

### RPOPLPUSH 安全队列
是提供一种安全队列的实现方式。但是个人建议，如果对于消息队列的要求比较高了，还是建议使用专业的消息队列框架。


## 4 发布/订阅
和消息队列一样，可以实现简单的发布订阅（一对多关系）功能。
发布
```
publish myTopic "hello"
```

订阅(阻塞)
```
subscribe myTopic
```

缺点也是并非安全的：
1. 不保证消息到达
2. 即发即收
3. 无状态

## 5 分布式锁
zookeeper 和 redis是用来做分布式锁比较常见的工具。
主要利用的他们的原子性。
zookeeper是元数据中心，天然适合做这个。
redis 因为是单线程，在高并发情况下，单线程保证资源的操作唯一性。

加锁
```
SET lock_key random_value NX PX 5000
```
> random_value 是客户端生成的唯一的字符串。
> NX 代表只在键不存在时，才对键进行设置操作。
> PX 5000 设置键的过期时间为5000毫秒。

思考题: 分布式锁超时了，但是程序还没有处理完，这种情况怎么处理？
这个问题在我面头条时被问到过，没有回答很好。大家可以想想，先留个坑，后面我会填上。

## 6 优先级队列
利用 sorted sets 任务过期管理，排行榜等等，都非常高效。
