一主多从，多机房情况下，都会遇到数据库一致性问题。

## CAP原则
不仅仅数据库，分布式都会涉及上面概念。
> Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。

> 一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）

>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）

>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。

针对p，既然不是单机了，就肯定必须有P，所以我们就是在CP和AP上面做权衡和选择。

几种一致性的情况：

### 强一致
当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。根据 CAP 理论，这种实现需要牺牲可用性。

### 弱一致性
系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。

### 最终一致性
弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。

## 现状
在工程实践上，为了保障系统的可用性，互联网系统大多将强一致性需求转换成最终一致性的需求，并通过系统执行幂等性的保证，保证数据的最终一致性。

## 经验
一般是尽力从业务上面去解决。或者针对特定场景，出具体方案。

例如我曾经遇到的case，读写分离的情况下，添加完数据后想立刻在列表中查询到（上游是一个add然后串行一个getlist接口）。

这个时候就涉及到主从同步的时间差了。特别是偶尔遇到跨机房，写入的主机是北方机器，南方的用户写入后，马上查询就会访问南方机房，这之间就会有约100ms的时间差。

最粗暴的方案是add然后sleep个200ms,getlist接口，这种能解决问题，但是是对服务器的一个消耗，导致大量等待线程。

第二个方案是，add后的查询指定主服务器实例，这样就保证写和读在一个服务器上，就没有数据同步问题，但是这个会增加主服务的压力。

第三个方案是升级下业务接口，合并请求，getlist数据时，如果列表中没有最新添加的数据，就将add的数据补充到list中，一起返回给上游。

## 总结
数据一致性如果是最终一致性能满足业务，那是最理想的。如果业务上需要用到一致性，那就可能需要针对业务最对应的方案设计了。目前看没有什么特别通用的技术方案。