## 事务隔离级别

SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）

> 读未提交：，一个事务还没提交时，它做的变更就能被别的事务看到。

> 读提交：一个事务提交之后，它做的变更才会被其他事务看到。

> 可重复读：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

> 串行化：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

### 读未提交
即便是事务没有commit，但是我们仍然能读到未提交的数据，这是所有隔离级别中最低的一种。

问题？
那就是我们在一个事务中可以随随便便读取到其他事务未提交的数据，这还是比较麻烦的，我们叫脏读。因为这个数据最终可能没有被提交。

使用场景: 读未提交 这种级别，数据库一般都不会用

### 读提交
当前会话只能读取到其他事务提交的数据，未提交的数据读不到。

问题？

那就是我们在会话同一个事务中，可能读取到两次不同的结果。这就造成了不可重复读，就是两次读取的结果不同。这种现象叫不可重复读。

### 可重复读 - MySQL默认的隔离级别

当前会话可以重复读，就是每次读取的结果集都相同，而不管其他事务有没有提交。

问题？

一个事务中读取的数据一致（可重复读）。及时被读的数据已经发生改变，但是我还是要保持和启动时一致。

### 串行化
当我们将当前会话的隔离级别设置为serializable的时候，其他会话对该表的写操作将被挂起。可以看到，这是隔离级别中最严格的。

问题？

但是这样做势必对性能造成影响。所以在实际的选用上，我们要根据当前具体的情况选用合适的。
